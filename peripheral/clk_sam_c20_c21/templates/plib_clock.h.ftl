/*******************************************************************************
  CLOCK PLIB

  Company:
    Microchip Technology Inc.

  File Name:
    plib_clock.h

  Summary:
    CLOCK PLIB Header File.

  Description:
    The Clock PLIB initializes all the oscillators based on the
    requirements.

*******************************************************************************/

/*******************************************************************************
Copyright (c) 2017 released Microchip Technology Inc.  All rights reserved.

Microchip licenses to you the right to use, modify, copy and distribute
Software only when embedded on a Microchip micro controller or digital signal
controller that is integrated into your product or third party product
(pursuant to the sublicense terms in the accompanying license agreement).

You should refer to the license agreement accompanying this Software for
additional information regarding your rights and obligations.

SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
(INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
*******************************************************************************/

#ifndef PLIB_CLOCK_H
#define PLIB_CLOCK_H

// *****************************************************************************
// *****************************************************************************
// Section: Included Files
// *****************************************************************************
// *****************************************************************************
/* This section lists the other files that are included in this file.
*/
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// DOM-IGNORE-BEGIN
#ifdef __cplusplus // Provide C++ Compatibility
extern "C" {
#endif

// DOM-IGNORE-END

// *****************************************************************************
// *****************************************************************************
// Section: Data Types
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************

<#if XOSC_INTERRUPT_MODE = true  || DPLL_INTERRUPT_MODE = true >
// *****************************************************************************
/* Oscillator Events

  Summary:
    List of possible events that can be generated by the oscillator.

  Description:
    This enumeration list the possible events that can be generated by the
    oscillators. These events are received in the Oscillator callback function
    which is registered by calling the OSCCTRL_CallbackRegister() function.

  Remarks:
    None.
*/

typedef enum
{
    /*  XOSC Clock Fail Indicator */
    OSCCTRL_EVENT_CLOCK_FAIL = 0x02,

    /* DPLL Lock Fail Indicator */
    OSCCTRL_EVENT_DPLL_LOCK_FAIL = 0x200,

    /* DPLL Locked Indicator */
    OSCCTRL_EVENT_PLL_LOCKED = 0x100

} OSCCTRL_EVENT;
</#if>

// *****************************************************************************
/* Generic Clock (GCLK) Generator

  Summary:
    List of available GCLK generators

  Description:
    This enumeration lists the available GCLK generators. This enum is used in
    any API that requires the GCLK instance to be specified.

  Remarks:
    None.
*/

typedef enum
{
<#list 0..8 as i>
    /** GCLK generator channel ${i} */
    GCLK_GENERATOR_${i} = ${i},

</#list>
} GCLK_GENERATOR;

// *****************************************************************************
/* GCLK Peripheral Channels enumeration

  Summary:
    List of available Peripheral Channels.

  Description:
    This enumeration lists the available GCLK Peripheral Channels. This enum is
    used in any API that requires the GCLK Peripheral Channel to be specified.

  Remarks:
    None.
*/

typedef enum
{
<#list 0..GCLK_MAX_ID as i>
    <#assign GCLK_ID_INDEX = "GCLK_ID_" + i + "_INDEX">
    <#assign GCLK_ID_NAME = "GCLK_ID_" + i + "_NAME">
    <#assign GCLK_ID_CHEN = "GCLK_ID_" + i + "_CHEN">
        <#if .vars[GCLK_ID_CHEN]?has_content>
    /* GCLK Channel Index for ${.vars[GCLK_ID_NAME]} */
    GCLK_PERIPHERAL_CHANNEL_${.vars[GCLK_ID_NAME]} = ${.vars[GCLK_ID_INDEX]},

        </#if>
</#list>
} GCLK_PERIPHERAL_CHANNEL;

// *****************************************************************************
/* APB Main Clock for peripherals.

  Summary:
    Lists the APB Main Peripheral Clock Peripherals.

  Description:
    This enumeration lists the available APB Main Peripheral Clock Sources. The
    APB Main clock source to a peripheral must be enabled in order to access the
    peripheral registers.

  Remarks:
    None.
*/

typedef enum
{
    /* APBA Bridge Clock for PAC */
    MCLK_APB_CLOCK_PAC = 0,

    /* APBA Bridge Clock for PAC */
    MCLK_APB_CLOCK_PM = 1,

    /* APBA Bridge Clock for MCLK */
    MCLK_APB_CLOCK_MCLK = 2,

    /* APBA Bridge Clock for RSTC */
    MCLK_APB_CLOCK_RSTC = 3,

    /* APBA Bridge Clock for OSCCTRL */
    MCLK_APB_CLOCK_OSCCTRL = 4,

    /* APBA Bridge Clock for OSC32KCTRL */
    MCLK_APB_CLOCK_OSC32KCTRL = 5,

    /* APBA Bridge Clock for SUPC */
    MCLK_APB_CLOCK_SUPC = 6,

    /* APBA Bridge Clock for GCLK */
    MCLK_APB_CLOCK_GCLK = 7,

    /* APBA Bridge Clock for WDT */
    MCLK_APB_CLOCK_WDT = 8,

    /* APBA Bridge Clock for RTC */
    MCLK_APB_CLOCK_RTC = 9,

    /* APBA Bridge Clock for EIC */
    MCLK_APB_CLOCK_EIC = 10,

    /* APBA Bridge Clock for FREQM */
    MCLK_APB_CLOCK_FREQM = 11,

    /* APBA Bridge Clock for TSENS */
    MCLK_APB_CLOCK_TSENS = 12,

    /* APBB Bridge Clock for PORT */
    MCLK_APB_CLOCK_PORT = 32,

    /* APBB Bridge Clock for DSU */
    MCLK_APB_CLOCK_DSU = 33,

    /* APBB Bridge Clock for NVMCTRL */
    MCLK_APB_CLOCK_NVMCTRL = 34,

    /* APBB Bridge Clock for HMATRIXHS */
    MCLK_APB_CLOCK_HMATRIXHS = 37,

    /* APBC Bridge Clock for EVSYS */
    MCLK_APB_CLOCK_EVSYS = 64,

    /* APBC Bridge Clock for SERCOM0 */
    MCLK_APB_CLOCK_SERCOM0 = 65,

    /* APBC Bridge Clock for SERCOM1 */
    MCLK_APB_CLOCK_SERCOM1 = 66,

    /* APBC Bridge Clock for SERCOM2 */
    MCLK_APB_CLOCK_SERCOM2 = 67,

    /* APBC Bridge Clock for SERCOM3 */
    MCLK_APB_CLOCK_SERCOM3 = 68,

    /* APBC Bridge Clock for SERCOM4 */
    MCLK_APB_CLOCK_SERCOM4 = 69,

    /* APBC Bridge Clock for SERCOM5 */
    MCLK_APB_CLOCK_SERCOM5 = 70,

    /* APBC Bridge Clock for TCC0 */
    MCLK_APB_CLOCK_TCC0 = 73,

    /* APBC Bridge Clock for TCC1 */
    MCLK_APB_CLOCK_TCC1 = 74,

    /* APBC Bridge Clock for TCC2 */
    MCLK_APB_CLOCK_TCC2 = 75,

    /* APBC Bridge Clock for TC0 */
    MCLK_APB_CLOCK_TC0 = 76,

    /* APBC Bridge Clock for TC1 */
    MCLK_APB_CLOCK_TC1 = 77,

    /* APBC Bridge Clock for TC2 */
    MCLK_APB_CLOCK_TC2 = 78,

    /* APBC Bridge Clock for TC3 */
    MCLK_APB_CLOCK_TC3 = 79,

    /* APBC Bridge Clock for TC4 */
    MCLK_APB_CLOCK_TC4 = 80,

    /* APBC Bridge Clock for ADC0*/
    MCLK_APB_CLOCK_ADC0 = 81,

    /* APBC Bridge Clock for ADC1 */
    MCLK_APB_CLOCK_ADC1 = 82,

    /* APBC Bridge Clock for SDADC */
    MCLK_APB_CLOCK_SDADC = 83,

    /* APBD Bridge Clock for AC */
    MCLK_APB_CLOCK_AC = 84,

    /* APBC Bridge Clock for SAC*/
    MCLK_APB_CLOCK_DAC = 85,

    /* APBC Bridge Clock for PTC*/
    MCLK_APB_CLOCK_PTC = 86,

    /* APBC Bridge Clock for CCL */
    MCLK_APB_CLOCK_CCL = 87,

    /* APBD Bridge Clock for SERCOM6 */
    MCLK_APB_CLOCK_SERCOM6 = 96,

    /* APBD Bridge Clock for SERCOM7  */
    MCLK_APB_CLOCK_SERCOM7 = 97,

    /* APBD Bridge Clock for TC5 */
    MCLK_APB_CLOCK_TC5 = 98,

    /* APBD Bridge Clock for TC6 */
    MCLK_APB_CLOCK_TC6 = 99,

    /* APBD Bridge Clock for TC7 */
    MCLK_APB_CLOCK_TC7 = 100

} MCLK_APB_CLOCK;

// *****************************************************************************
/* AHB Main Clock for peripherals.

  Summary:
    Lists the AHB Main Peripheral Clock Peripherals.

  Description:
    This enumeration lists the available AHB Main Peripheral Clock Sources. The
    AHB Main clock source to a peripheral must be enabled so that the peripheral
    can perform AHB access.

  Remarks:
    None.
*/

typedef enum
{
    /* AHB Clock for the APBA */
    MCLK_AHB_CLOCK_APBA = 0x00000001,

    /* AHB Clock for the APBB */
    MCLK_AHB_CLOCK_APBB = 0x00000002,

    /* AHB Clock for the APBC */
    MCLK_AHB_CLOCK_APBC = 0x00000004,

    /* AHB Clock for the DSU */
    MCLK_AHB_CLOCK_DSU = 0x00000008,

    /* AHB Clock for the HMATRIXHS */
    MCLK_AHB_CLOCK_HMATRIXHS = 0x00000010,

    /* AHB Clock for the NVMCTRL */
    MCLK_AHB_CLOCK_NVMCTRL = 0x00000020,

    /* AHB Clock for the HSRAM */
    MCLK_AHB_CLOCK_HSRAM = 0x00000040,

    /* AHB Clock for the DMAC */
    MCLK_AHB_CLOCK_DMAC = 0x00000080,

    /* AHB Clock for the CAN0 */
    MCLK_AHB_CLOCK_CAN0 = 0x00000100,

    /* AHB Clock for the CAN1 */
    MCLK_AHB_CLOCK_CAN1 = 0x00000200,

    /* AHB Clock for the PAC */
    MCLK_AHB_CLOCK_PAC = 0x00000400,

    /* AHB Clock for the DIVAS*/
    MCLK_AHB_CLOCK_DIVAS = 0x00001000,

    /* AHB Clock for the APBD */
    MCLK_AHB_CLOCK_APBD = 0x00002000

} MCLK_AHB_CLOCK;

// *****************************************************************************

// *****************************************************************************
// *****************************************************************************
// Section: Interface Routines
// *****************************************************************************
// *****************************************************************************
/* The following functions make up the methods (set of possible operations) of
this interface.
*/

// *****************************************************************************

// *****************************************************************************
// *****************************************************************************
// Section: Interface Routines
// *****************************************************************************
// *****************************************************************************
/* The following functions make up the methods (set of possible operations) of
this interface.
*/

// *****************************************************************************
/* Function:
    void CLOCK_Initialize (void);

  Summary:
    Initializes all the modules related to the system clock.

  Description:
    This function initializes the clock as defined by the MHC and Clock Manager
    selections. The function will configure the NVM Flash Wait states based on
    the configured CPU operational frequency. It will then configure the
    oscillators.

    For each of the clock sources (External Oscillator, Digital Phase Locked
    Loop, Internal 48MHz Oscillator, External 32KHz oscillator and the Internal
    32KHz oscillator) enabled in MHC, the function will configure the clock
    settings and will then wait till the clock is ready. In case of DPLL, the
    function will wait till a lock is obtained.

    The function will then configure the Generic clock generators based on MHC
    configurations. If a Generic Clock is enabled in MHC, this will be enabled
    in the CLOCK_Initialize() function. The function will apply the CPU clock
    divider and will wait for the Main Clock module to get ready. If the Main
    Clock to the Peripheral APB and AHB interfaces was enabled in MHC, these
    will be enabled in the CLOCK_Initialize() function. If the Peripheral Clock
    Channels were enabled in MHC, these will be enabled in the
    CLOCK_Initialize() function.

    The peripheral AHB and APB main clock and peripheral channel clocks will be
    enabled when the peripheral specific initialize functions are called. This
    will override the setting in MHC. The Generic Clock Generator source for
    desired peripheral channel must be configured in MHC.

  Precondition:
    MHC GUI should be configured with the right values. Incorrect configuration
    of the Clock will result in incorrect peripheral behavior or a non
    functional device.

  Parameters:
    None.

  Returns:
    None.

  Example:
    <code>
        CLOCK_Initialize();
    </code>

  Remarks:
    This function should be called before calling other Clock library functions.
*/

void CLOCK_Initialize (void);
<#if CONFIG_CLOCK_XOSC_ENABLE = true>

// *****************************************************************************
/* Function:
    void OSCCTRL_XOSCEnable (bool enable);

  Summary:
    Enables and disables the External Oscillator.

  Description:
    This function enables or disables the external oscillator. The application
    may need to disable the oscillator to reduce power consumption.

    After enabling the external oscillator, the OSCCTRL_XOSCIsReady() function
    must be called to check if the oscillator is ready.

  Precondition:
    MHC GUI should be configured with the right values.

  Parameters:
    enable - If true, the oscillator is enabled. If false, oscillator is
    disabled.

  Returns:
    None.

  Example:
    <code>

    // Enable the external oscillator
    OSCCTRL_XOSCEnable (true);
    while(OSCCTRL_XOSCIsReady() == false);

    </code>

  Remarks:
    The initial enable/disable state of the oscillator is controlled by
    MHC/Clock Manager settings. If the oscillator was enabled in MHC/Clock
    Manager settings, the application does not need to call this function to
    enable the oscillator.

    Disabling the oscillator can cause the device to become non functional if
    the oscillator is sourcing the clock to the PIC. All implications of
    enabling and disabling a oscillator should be considered and well
    understood.
*/

void OSCCTRL_XOSCEnable( bool enable );

// *****************************************************************************
/* Function:
    bool OSCCTRL_XOSCIsReady ( void );

  Summary:
    Indicates readiness of the external oscillator.

  Description:
    This function returns true if the external oscillator is ready to be used.
    Once enabled, the oscillator will need a certain amount of time to stabilize
    on the correct frequency.  The oscillator output during this stabilization
    is masked. The function returns true once the external clock or crystal
    oscillator is stable and ready to be used as clock source.

  Precondition:
    MHC GUI should be configured with the desired oscillator startup time.

  Parameters:
    None.

  Returns:
    true - Oscillator is stable and ready.
    false - Oscillator is not yet ready.

  Example:
    <code>
    // Assume that oscillator was disabled.  We enable the external oscillator
    // and then wait till it is ready.

    OSCCTRL_XOSCEnable(true);
    while(OSCCTRL_XOSCIsReady() == false);

    </code>

  Remarks:
    The CLOCK_Initialize() function will ensure that all configured clock
    sources are stable before exiting. It is not necessary to call
    OSCCTRL_XOSCIsReady() function after the CLOCK_Initialize() function. The
    OSCCTRL_XOSCIsReady() should be called to check oscillator status only when
    the application has itself, disabled the external oscillator.
*/

bool OSCCTRL_XOSCIsReady( void );
<#if CONFIG_CLOCK_XOSC_CFDEN = true >

// *****************************************************************************
/* Function:
    bool OSCCTRL_XOSCFailureIsActive( void );

  Summary:
    Indicates the XOSC failure status.

  Description:
    This function returns true if a failure is currently being detected on the
    external oscillator.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    true - Failure is being detected on the external oscillator.
    false - Failure is not being detected on the external oscillator.

  Example:
    <code>
    // Refer to the description of the  OSCCTRL_XOSCMainClockRevert() function
    // for information on API usage.
    </code>

  Remarks:
    None.
*/

bool OSCCTRL_XOSCFailureIsActive( void );

// *****************************************************************************
/* Function:
    bool OSCCTRL_XOSCSafeClockIsActive( void );

  Summary:
    Indicates the XOSC Clock is replaced by the safe clock

  Description:
    This function returns true if the Clock Failure detection system has
    detected a failure and the system has now switched to the safe clock.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    true - External oscillator has failed and system is currently using the safe
    clock.

    false - System is not using the safe clock. It is using the external
    oscillator.

  Example:
    <code>
    // Refer to the description of the  OSCCTRL_XOSCMainClockRevert() function
    // for information on API usage.
    </code>

  Remarks:
    None.
*/

bool OSCCTRL_XOSCSafeClockIsActive( void );

// *****************************************************************************
/* Function:
    void OSCCTRL_XOSCMainClockRevert( void );

  Summary:
    Switches the system back to the external oscillator.

  Description:
    This function will switch the system clock from the safe clock to the
    external oscillator. This function should be called when the application is
    able to verify that the external oscillator is functional.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    None

  Example:
    <code>

    volatile oscillatorHasFailed = false;

    void MYClockSystemCallback(OSCCTRL_EVENT event, uintptr_t context)
    {
        if(event == OSCCTRL_EVENT_CLOCK_FAIL)
        {
            oscillatorHasFailed = true;
        }
    }

    // Initialize the clock and register a callback.
    CLOCK_Initialize();
    OSCCTRL_CallbackRegister(MYClockSystemCallback, NULL)

    // While performing other tasks, we can check if the the oscillator has
    // failed.

    if(oscillatorHasFailed)
    {
        //Confirm the safe clock is active
        if(OSCCTRL_XOSCSafeClockIsActive())
        {
            // In this example, we will wait till the external oscillator comes
            // back on line.

            while(OSCCTRL_XOSCFailureIsActive());

            // The above loop will exit when the external oscillator is
            // operational.

            if(OSCCTRL_XOSCIsReady())
            {
                // Revert back to the main clock.
                OSCCTRL_XOSCMainClockRevert();
            }
        }
    }

    </code>

  Remarks:
    None.
*/

void OSCCTRL_XOSCMainClockRevert( void );
</#if>
</#if>

<#if CONFIG_CLOCK_OSC48M_ENABLE = true>

// *****************************************************************************
/* Function:
    void OSCCTRL_OSC48MEnable( bool enable );

  Summary:
    Enables and disables the Internal 48MHz Oscillator.

  Description:
    This function enables or disables the Internal 48MHz oscillator. This function
    could be called to disable the oscillator to save power.

    After enabling the oscillator, the OSCCTRL_OSC48MIsReady() function must
    called to call to check if the oscillator has stabilized.

  Precondition:
    MHC GUI should be configured with the right values.

  Parameters:
    enable - If true, the oscillator is enabled. If false, oscillator is
    disabled.

  Returns:
    None.

  Example:
    <code>
        // Disable the internal 48MHz oscillator.
        OSCCTRL_OSC48MEnable(false);
    </code>

  Remarks:
    The initial enable/disable state of the oscillator is controlled by
    MHC/Clock Manager settings. If the oscillator was enabled in MHC/Clock
    Manager settings, the application does not need to call this function to
    enable the oscillator. Also note that the 48MHz Internal oscillator is
    enabled by default at power up.
*/

void OSCCTRL_OSC48MEnable( bool enable );

// *****************************************************************************
/* Function:
    bool OSCCTRL_OSC48MIsReady( void );

  Summary:
    Indicates readiness of the internal 48MHz oscillator.

  Description:
    This function returns true if the internal 48MHz oscillator is ready to be
    used.  Once enabled, the oscillator will need a certain amount of time to
    stabilize on the correct frequency.  The oscillator output during this
    stabilization is masked. The function returns true once the internal 48MHz
    oscillator is stable and ready to be used as clock source.

  Precondition:
    MHC GUI should be configured with the desired oscillator startup time. The
    application must ensure that the oscillator is disabled before enablint it.

  Parameters:
    None.

  Returns:
    true - Oscillator is stable and ready.
    false - Oscillator is not yet ready.

  Example:
    <code>
    // Assume that oscillator was disabled, the system was put to sleep and has
    // now woken up from sleep. We must first make sure the oscillator is
    // complete disabled before enabling it. We then enable the internal
    // oscillator and then wait till it is ready.


    while(OSCCTRL_OSC48MIsReady() == true);
    OSCCTRL_OSC48MEnable(true);
    while(OSCCTRL_OSC48MEnable() == false);

    </code>

  Remarks:
    The CLOCK_Initialize() function will ensure that all configured clock
    sources are stable before exiting. It is not necessary to call
    OSCCTRL_OSC48MIsReady() function after the CLOCK_Initialize() function. The
    OSCCTRL_OSC48MIsReady() should be called to check oscillator status only when
    the application has itself disabled the internal oscillator.
*/

bool OSCCTRL_OSC48MIsReady( void );
</#if>

<#if CONFIG_CLOCK_DPLL_ENABLE = true >

// *****************************************************************************
/* Function:
    void OSCCTRL_DPLLEnable( bool enable );

  Summary:
    Enables or disables the Digital Phase Locked Loop (DPLL).

  Description:
    This function enables or disables the DPLL. This function could be called to
    disable the DPLL while entering the available sleep modes and re-enabling it
    exiting from the sleep mode.

  Precondition:
    MHC GUI should be configured with the right values.

  Parameters:
    enable - If true, the DPLL is enabled. If false, DPLL is disabled.

  Returns:
    None.

  Example:
    <code>
        // Disable the DPLL.
        OSCCTRL_DPLLEnable(false);
    </code>

  Remarks:
    The initial enable/disable state of the DPLL is controlled by MHC/Clock
    Manager settings. If the DPLL was enabled in MHC/Clock Manager settings, the
    application does not need to call this function to enable the DPLL.
*/

void OSCCTRL_DPLLEnable( bool enable );

// *****************************************************************************
/* Function:
    bool OSCCTRL_DPLLIsLocked( void );

  Summary:
    Returns the lock status of the DPLL.

  Description:
    This function returns the lock status of the DPLL. When locked, the DPLL
    output is stable.

  Precondition:
    MHC GUI should be configured with the right values. The configuration of
    DPLL Lock Time and Fast Wake up in MHC will affect the operation of the Lock
    Logic. Enabling Fast Wake up may cause the DPLL output to be enabled even if
    the PLL is not locked.

  Parameters:
    None.

  Returns:
    true - DPLL is locked.
    false - DPLL is not locked.

  Example:
    <code>

    // Enable the DPLL.
    OSCCTRL_DPLLEnable(true);
    while(OSCCTRL_DPLLIsLocked() == false);

    </code>

  Remarks:
    None.
*/

bool OSCCTRL_DPLLIsLocked( void );
</#if>

<#if XOSC_INTERRUPT_MODE = true || DPLL_INTERRUPT_MODE = true >

// *****************************************************************************
/* External Oscillator Callback Function Pointer Type.

  Summary:
    Defines the data type and function signature for the External Oscillator
    callback function.

  Description:
    This data type defines the function signature for the External Oscillator
    callback function. The External Oscillator will call back the client's
    function with this signature when it needs to send asynchronous event
    notifications to the client. The event type is passed in the event parameter
    of the callback function. The context parameter is an application defined
    data object specified at the time of registering the callback function and
    is returned in the context parameter of the callback function.

  Precondition:
    The CLOCK_Initialize() initialize function should have been called. The
    callback function should have been registered through
    OSCCTRL_CallbackRegister() function.

  Parameters:
    event - Specifies the events which are active at the time of the callback
    function was called.

    context  - Allows the caller to provide a context value (usually a pointer
    to the callers context for multi-instance clients).

  Returns:
    None.

  Example:
    <code>

    void MyOscillatorCallback (OSCCTRL_EVENT event, uintptr_t context )
    {
        if(event & OSCCTRL_EVENT_CLOCK_FAIL)
        {
            // Handle the clock failure.
        }
        else if(event & OSCCTRL_EVENT_DPLL_LOCK_FAIL)
        {
            // DLL is not locked any more.
        }
    }

    // Register the callback function. Specify the context as NULL.
    OSCCTRL_CallbackRegister(MyOscillatorCallback, NULL);

    </code>

  Remarks:
    None.
*/

typedef void (*OSCCTRL_CALLBACK)(OSCCTRL_EVENT event, uintptr_t context);

// *****************************************************************************
/* Function:
    void OSCCTRL_CallbackRegister (OSCCTRL_CALLBACK callback, uintptr_t context);

  Summary:
    Register the function to be called when an External Oscillator or DPLL event
    is generated.

  Description:
    This function registers the callback function to be called when the External
    Oscillator has failed or when the DPLL has lost lock or when the DPLL has
    achieved lock. The event type is passed into the callback function when the
    function is called.

  Precondition:
    The External Oscillator and/or should have been configured in MHC and
    enabled.

  Parameters:
    callback - Pointer to the OSCCTRL_CALLBACK type of function that will be
    called when the oscillator or DPLL event has occurred.

    context - Context value to be passed into the callback function when it
    called.

  Returns:
    None.

  Example:
    <code>

    //Refer to the code example provided in the description of the
    //OSCCTRL_CALLBACK function pointer type.

    </code>

  Remarks:
    None.
*/

void OSCCTRL_CallbackRegister (OSCCTRL_CALLBACK callback, uintptr_t context);

// *****************************************************************************
/* Function:
    void OSCCTRL_Handler(void);

  Summary:
    Handler that handles the XOSC and DPLL Interrupts.

  Description:
    This Function is called from the handler to handle the XOSC Failure and DPLL
    lock based on the Interrupts.

  Precondition:
    This function must be called After the CLOCK_Initialize().

  Parameters:
    None.

  Returns:
    None.

  Example:
    <code>
        void System_Handler(void)
        {
            OSCCTRL_Handlervoid);
        }
    </code>

  Remarks:
    None.
*/

void OSCCTRL_Handler(void);
</#if>
<#if XOSC32K_INTERRUPT_MODE = true >

// *****************************************************************************
/* External 32KHz Oscillator Clock Failure Callback Function Pointer Type.

  Summary:
    Defines the data type and function signature for the External 32KHz Oscillator
    clock failure detection callback function.

  Description:
    This data type defines the function signature for the External 32KHz
    Oscillator clock failure detection callback function. The External 32KHz
    Oscillator will call back the client's function with this signature when it
    needs to notify the client of oscillator failure.  The context parameter is
    an application defined data object specified at the time of registering the
    callback function and is returned in the context parameter of the callback
    function.

  Precondition:
    The CLOCK_Initialize() initialize function should have been called. The
    callback function should have been registered through
    OSC32KCTRL_CallbackRegister() function.

  Parameters:
    context  - Allows the caller to provide a context value (usually a pointer
    to the callers context for multi-instance clients).

  Returns:
    None.

  Example:
    <code>

    void MyOscillatorFailureCallback (uintptr_t context )
    {
        // This means the 32KHz clock has failed.
    }

    // Register the callback function. Specify the context as NULL.
    OSC32KCTRL_CallbackRegister(MyOscillatorFailureCallback, NULL);

    </code>

  Remarks:
    None.
*/

typedef void (*OSC32KCTRL_CFD_CALLBACK)(uintptr_t context);

</#if>
<#if CONF_CLOCK_XOSC32K_ENABLE = true >

// *****************************************************************************
/* Function:
    void OSC32KCTRL_XOSC32KEnable( bool enable );

  Summary:
    Enables and disables the External 32KHz Oscillator.

  Description:
    This function enables or disables the external 32KHz oscillator. This
    function could be called to disable the oscillator to save power.

    After enabling the oscillator, the OSC32KCTRL_XOSC32KIsReady() function must
    be called to check if the oscillator has stabilized.

  Precondition:
    MHC GUI should be configured with the right values.

  Parameters:
    enable - If true, the oscillator is enabled. If false, oscillator is
    disabled.

  Returns:
    None.

  Example:
    <code>

    // Enable the external 32KHz oscillator and wait till it is ready.
    OSC32KCTRL_XOSC32KEnable(true);
    while(OSC32KCTRL_XOSC32KIsReady() == false);

    // Disable oscillator.
    OSC32KCTRL_XOSC32KEnable(false);

    </code>

  Remarks:
    The initial enable/disable state of the oscillator is controlled by
    MHC/Clock Manager settings. If the oscillator was enabled in MHC/Clock
    Manager settings, the application does not need to call this function to
    enable the oscillator.
*/

void OSC32KCTRL_XOSC32KEnable( bool enable );

// *****************************************************************************
/* Function:
    bool OSC32KCTRL_XOSC32KIsReady( void );

  Summary:
    Indicates readiness of the external 32KHz oscillator.

  Description:
    This function returns true if the external 32KHz oscillator is ready to be
    used.  Once enabled, the oscillator will need a certain amount of time to
    stabilize on the correct frequency.  The oscillator output during this
    stabilization is masked. The function returns true once the external clock
    or crystal oscillator is stable and ready to be used as clock source.

  Precondition:
    MHC GUI should be configured with the desired oscillator startup time.

  Parameters:
    None.

  Returns:
    true - Oscillator is stable and ready.
    false - Oscillator is not yet ready.

  Example:
    <code>
    // Assume that oscillator was disabled, the system was put to sleep and has
    // now woken up from sleep. We enable the external oscillator and then wait
    // till it is ready.

    OSCCTRL_XOSC32KEnable(true);
    while(OSCCTRL_XOSCIsReady() == false);

    </code>

  Remarks:
    The CLOCK_Initialize() function will ensure that all configured clock
    sources are stable before exiting. It is not necessary to call
    OSCCTRL_XOSC32KIsReady() function after the CLOCK_Initialize() function. The
    OSCCTRL_XOSC32KIsReady() should be called to check oscillator status only
    when the application has itself disabled the external 32KHz oscillator.
*/

bool OSC32KCTRL_XOSC32KIsReady( void );
<#if XOSC32K_CFDEN = true >

// *****************************************************************************
/* Function:
    bool OSCCTRL_XOSC32KFailureIsActive( void );

  Summary:
    Indicates the XOSC32K failure status.

  Description:
    This function returns true if a failure is currently being detected on the
    external 32K oscillator.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    true - Failure is being detected on the external oscillator.
    false - Failure is not being detected on the external oscillator.

  Example:
    <code>
    // Refer to the description of the  OSCCTRL_XOSC32KMainClockRevert() function
    // for information on API usage.
    </code>

  Remarks:
    None.
*/

bool OSC32KCTRL_XOSC32KFailureIsActive( void );

// *****************************************************************************
/* Function:
    bool OSCCTRL_XOSC32KSafeClockIsActive( void );

  Summary:
    Indicates the XOSC32K Clock is replaced by the safe clock

  Description:
    This function returns true if the Clock Failure detection system has
    detected a failure and the system has now switched to the safe clock.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    true - External oscillator has failed and system is currently using the safe
    clock.

    false - System is not using the safe clock. It is using the external
    oscillator.

  Example:
    <code>
    // Refer to the description of the  OSCCTRL_XOSC32KMainClockRevert() function
    // for information on API usage.
    </code>

  Remarks:
    None.
*/

bool OSC32KCTRL_XOSC32KSafeClockIsActive( void );

// *****************************************************************************
/* Function:
    void OSCCTRL_XOSC32KMainClockRevert( void );

  Summary:
    Switches the system back to the external oscillator.

  Description:
    This function will switch the system clock from the safe clock to the
    external oscillator. This function should be called when the application is
    able to verify that the external oscillator is functional.

  Precondition:
    This feature is only available if Clock Failure Detection is enabled through
    MHC. The safe clock should have been enabled and configured as desired.

  Parameters:
    None.

  Returns:
    None

  Example:
    <code>

    volatile oscillatorHasFailed = false;

    void MYClockSystemCallback(OSCCTRL_EVENT event, uintptr_t context)
    {
        if(event == OSCCTRL_EVENT_CLOCK_FAIL)
        {
            oscillatorHasFailed = true;
        }
    }

    // Initialize the clock and register a callback.
    CLOCK_Initialize();
    OSCCTRL_CallbackRegister(MYClockSystemCallback, NULL)

    // While performing other tasks, we can check if the the oscillator has
    // failed.

    if(oscillatorHasFailed)
    {
        //Confirm the safe clock is active
        if(OSCCTRL_XOSC32KSafeClockIsActive())
        {
            // In this example, we will wait till the external oscillator comes
            // back on line.

            while(OSCCTRL_XOSC32KFailureIsActive());

            // The above loop will exit when the external oscillator is
            // operational.

            if(OSCCTRL_XOSC32KIsReady())
            {
                // Revert back to the main clock.
                OSCCTRL_XOSC32KMainClockRevert();
            }
        }
    }

    </code>

  Remarks:
    None.
*/

void OSC32KCTRL_XOSC32KMainClockRevert( void );
</#if>
</#if>

<#if CONF_CLOCK_OSC32K_ENABLE = true >

// *****************************************************************************
/* Function:
    void OSC32KCTRL_OSC32KEnable( bool enable );

  Summary:
    Enables and disables the Internal 32KHz Oscillator.

  Description:
    This function enables or disables the Internal 32KHz oscillator. This function
    could be called to disable the oscillator to reduce power.

    After enabling the oscillator, the OSC32KCTRL_OSC32KIsReady() function must
    called to call to check if the oscillator has stabilized.

  Precondition:
    MHC GUI should be configured with the right values.

  Parameters:
    enable - If true, the oscillator is enabled. If false, oscillator is
    disabled.

  Returns:
    None.

  Example:
    <code>
        // Disable the internal 32KHz oscillator.
        OSC32KCTRL_OSC32KEnable(false);
    </code>

  Remarks:
    The initial enable/disable state of the oscillator is controlled by
    MHC/Clock Manager settings. If the oscillator was enabled in MHC/Clock
    Manager settings, the application does not need to call this function to
    enable the oscillator.
*/

void OSC32KCTRL_OSC32KEnable( bool enable );

// *****************************************************************************
/* Function:
    bool OSC32KCTRL_OSC32KIsReady( void );

  Summary:
    Indicates readiness of the internal 32KHz oscillator.

  Description:
    This function returns true if the internal 32KHz oscillator is ready to be
    used. Once enabled, the oscillator will need a certain amount of time to
    stabilize on the correct frequency.  The oscillator output during this
    stabilization is masked. The function returns true once the internal 32KHz
    oscillator is stable and ready to be used as clock source.

  Precondition:
    MHC GUI should be configured with the desired oscillator startup time.

  Parameters:
    None.

  Returns:
    true - Oscillator is stable and ready.
    false - Oscillator is not yet ready.

  Example:
    <code>
    // Assume that oscillator was disabled, the system was put to sleep and has
    // now woken up from sleep. We then enable the internal oscillator and then
    // wait till it is ready.

    OSC32KCTRL_OSC32KIsReady(true);
    while(OSC32KCTRL_OSC32KIsReady() == false);

    </code>

  Remarks:
    The CLOCK_Initialize() function will ensure that all configured clock
    sources are stable before exiting. It is not necessary to call
    OSC32KCTRL_OSC32KIsReady() function after the CLOCK_Initialize() function.
    The OSC32KCTRL_OSC32KIsReady() should be called to check oscillator status
    only when the application has itself disabled the internal oscillator.
*/

bool OSC32KCTRL_OSC32KIsReady( void );
</#if>

<#if XOSC32K_INTERRUPT_MODE = true >

// *****************************************************************************
/* Function:
    void OSC32KCTRL_CallbackRegister (OSC32KCTRL_CFD_CALLBACK callback,
                                                    uintptr_t context);

  Summary:
    Register the function to be called when the 32KHz External Oscillator has
    failed.

  Description:
    This function register the function to be called when the 32KHz External
    Oscillator has failed.

  Precondition:
    The 32KHz External Oscillator should have been configured in MHC and
    enabled.

  Parameters:
    callback - Pointer to the OSC32KCTRL_CFD_CALLBACK type of function that will
    be called when a clock failure is detected. This can be NULL, in which case
    no callback will be generated.

    context - Context value to be passed into the callback function when it
    called.

  Returns:
    None.

  Example:
    <code>

    //Refer to the code example provided in the description of the
    //OSC32KCTRL_CFD_CALLBACK function pointer type.

    </code>

  Remarks:
    None.
*/

void OSC32KCTRL_CallbackRegister (OSC32KCTRL_CFD_CALLBACK callback, uintptr_t context);

// *****************************************************************************
/* Function:
    void OSC32KCTRL_Handler(void);

  Summary:
    Handler that handles the XOSC32K Interrupts.

  Description:
    This Function is called from the handler to handle the XOSC32K Failure
    Interrupts.

  Precondition:
    This function must be called After the CLOCK_Initialize().

  Parameters:
    None.

  Returns:
    None.

  Example:
    <code>
        void System_Handler(void)
        {
            OSC32KCTRL_Handler();
        }
    </code>

  Remarks:
    This function must be called After the CLOCK_Initialize().
*/

void OSC32KCTRL_Handler(void);
</#if>

// *****************************************************************************
/* Function:
    void GCLK_GeneratorEnable(GCLK_GENERATOR gclk, bool enable);

  Summary:
    Enables or disables the GCLK Generator.

  Description:
    This function will enable or disable the selected generic clock generator.
    The generator to be modified is specified by gclk parameter. A generator may
    be disabled to save power while entering a low power mode and enabled again
    when peripheral operation needs to be resumed.

  Precondition:
    The GCLK Generator should have been configured via the Clock Manager or MHC.

  Parameters:
    gclk - Generator to enable or disable.

    enable - If true, generator is enabled. If false, generator is disabled.

  Returns:
    None.

  Example:
    <code>

    bool gclkenablevalue = true;
    GCLK_GENERATOR gclk = GCLK_GENERATOR_8;

    GCLK_GeneratorEnable(gclk, gclkenablevalue);

    </code>

  Remarks:
    Generic Clock generators are configured and enabled via MHC. The configured
    generators are updated in the CLOCK_Initialize() function. It is not
    necessary to call the GCLK_GeneratorEnable() function to enable a generator
    that was already enabled in MHC. The GCLK_GeneratorEnable() should only be
    called to enable a generator that was explicitly disabled by the application
    during execution.
*/

void GCLK_GeneratorEnable(GCLK_GENERATOR gclk, bool enable);

// *****************************************************************************
/* Function:
    void GCLK_PeripheralChannelEnable (GCLK_PERIPHERAL_CHANNEL peripheralChannel,
                                       bool enable);

  Summary:
    Enables or disables the Peripheral Clock Channel.

  Description:
    This function will enable or disable the specified peripheral channel.
    Enabling the peripheral clock channel will enable the core clock that is
    required for peripheral to function. The peripheral clock channel may be
    disable to stop the clock to a peripheral to save power.

  Precondition:
    Required GCLK and Peripheral Clock Channel settings should be set from the
    MHC or Clock Manager.

  Parameters:
    peripheralChannel - Peripheral Clock Channel to enable or disable.

    enable - If true, peripheral clock channel is enabled. If false, peripheral
    clock channel is disabled.

  Returns:
    None.

  Example:
    <code>
    bool perChannelEnable = true;
    GCLK_PERIPHERAL_CHANNEL channelnum = GCLK_PERIPHERAL_CHANNEL_DAC;

    GCLK_PeripheralChannelEnable(channelnum, perChannelEnable);
    </code>

  Remarks:
    Peripheral Clock channels are configured and enabled via MHC or the Clock
    Manager. The requested generators are updated in the CLOCK_Initialize()
    function. It is not necessary to call the GCLK_PeripheralChannelEnable()
    function to enable a peripheral clock channel that was already enabled in
    MHC. The GCLK_PeripheralChannelEnable() should only be called to enable a
    peripheral clock channel that was explicitly disabled by the application
    during execution.

    A peripheral will enable its own peripheral clock channel when it's
    initialize function is called, even though the peripheral clock channel may
    have been disabled in MHC or the Clock Manager. This ensures the
    peripheral's clock requirements are met when it is required to run. The
    Peripheral Clock Channel Generator Source should still be configured through
    MHC or the Clock Manager.
*/

void GCLK_PeripheralChannelEnable (GCLK_PERIPHERAL_CHANNEL peripheralChannel, bool enable);

// *****************************************************************************
/* Function:
    void MCLK_APBClockEnable ( MCLK_APB_CLOCK peripheral, bool enable );

  Summary:
    Enables or disables APB Clock.

  Description:
    This function will enable or disable the APB clock for the selected
    peripheral given by the peripheral parameter. Enabling the peripheral APB
    clock makes the peripheral register accessible.

  Precondition:
    None.

  Parameters:
    peripheral - Peripheral whose APB clock should be enabled or disabled.

    enable - If true, APB clock is enabled. If false, APB clock is disabled.

  Returns:
    None.

  Example:
    <code>

    // To enable the PM Clock on the APB Bridge
    bool apbClockEnable = true;
    MCLK_APB_CLOCK apbClock = MCLK_APB_CLOCK_PM;
    MCLK_APBClockEnable (apbClock, bool enable );

    </code>

  Remarks:
    Peripheral APB Clocks are configured and enabled via MHC or the Clock
    Manager. It is not necessary to call the MCLK_APBClockEnable() function to
    enable a peripheral APB clock that was already enabled in MHC. The
    MCLK_APBClockEnable() should only be called to enable a peripheral APB clock
    was explicitly disabled by the application during execution.

    A peripheral will enable its own APB clock when it's initialize function is
    called, even though that peripherals APB clock  may have been disabled in
    MHC or the Clock Manager. This ensures the peripheral's clock requirements
    are met when it is required to run.
*/

void MCLK_APBClockEnable ( MCLK_APB_CLOCK peripheral, bool enable );

// *****************************************************************************
/* Function:
    void MCLK_AHBClockEnable ( MCLK_AHB_CLOCK ahbClock, bool enable );

  Summary:
    Enables or disables AHB Clock.

  Description:
    This function will enable or disable the AHB clock for the selected
    peripheral. Peripherals such CAN and DMAC use the AHB to access other memory
    regions. Enabling the AHB clock enables this access.

  Precondition:
    None.

  Parameters:
    ahbClock - Peripheral whose AHB clock needs to be enabled or disabled.

    enable - If true, peripheral AHB clock is enabled. If false, peripheral AHB
    clock is disabled.

  Returns:
    None.

  Example:
    <code>

    //To enable the APBA On the AHB
    bool ahbClockEnable = true;
    MCLK_AHB_CLK apbClock = MCLK_AHB_CLK_APBA;
    MCLK_AHBClockEnable (ahbClock, bool enable );

    </code>

  Remarks:
    Peripheral AHB Clocks are configured and enabled via MHC or the Clock
    Manager. It is not necessary to call the MCLK_AHBClockEnable() function to
    enable a peripheral AHB clock that was already enabled in MHC. The
    MCLK_AHBClockEnable() should only be called to enable a peripheral AHB clock
    was explicitly disabled by the application during execution.

    A peripheral will enable its own AHB clock when it's initialize function is
    called, even though that peripherals AHB clock  may have been disabled in
    MHC or the Clock Manager. This ensures the peripheral's clock requirements
    are met when it is required to run.
*/

void MCLK_AHBClockEnable ( MCLK_AHB_CLOCK ahbClock, bool enable );

// *****************************************************************************
/* Function:
    bool MCLK_ClockIsReady ( void );

  Summary:
    Returns the status of the Main Clock (MCLK).

  Description:
    This function returns true if the Main clock is ready. If the CPU clock
    divide values are changed, there is some delay involved till the new setting
    become active. This function can be called to check the readiness of the
    MCLK in such a case.

  Precondition:
    None.

  Parameters:
    None.

  Returns:
    true - MCLK is ready.

    false - MCLK is not ready.

  Example:
    <code>
        MCLK_ClockIsReady();
    </code>

  Remarks:
    It is not necessary to for the application to call this function unless the
    CPU clock speed or source is being changed. If the CPU clock speed is being
    changed, then the application must call this function to check if the CPU
    clock is ready.

    The CLOCK_Initialize() function will ensure that MCLK is ready before
    exiting the function.
*/

bool MCLK_ClockIsReady ( void );

#ifdef __cplusplus // Provide C++ Compatibility
}
#endif

#endif /* PLIB_CLOCK_H */

